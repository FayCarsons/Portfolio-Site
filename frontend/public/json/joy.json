{
  "title": "joy",
  "date": "February 20, 2024",
  "header": "<h1 class=\"font-mono text-3xl md:text-4xl my-4 mx-auto font-semibold\">Developing a functional creative coding library in OCaml</h1>",
  "body": "<p class=\"font-mono text-sm my-4 mx-auto\">I have taken a unique path during my short time as a developer. Beginning with\nClojure, with which I mostly wrote <a href=\"https://shadertoy.com\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">Shadertoy</a> style shader\nsketches, then moving onto performance-focused image processing apps in Rust,\nand now MLs: I have felt lost, confounded, or otherwise confused at many points.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">The resources for absolute beginners in these spaces are few and far between.\nIt's generally accepted that these are 'hard' languages (which I don't agree\nwith) and that people who are brand new to computer science should start with\nimperative languages like Python or Javascript. This has always been frustrating\nto me, as I feel it is likely responsible for these languages achieving ubiquity\nwhile functional languages, for the most part, have not.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">When I was offered the opportunity to intern for <a href=\"https://tarides.com\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">Tarides</a>, building a creative\ncoding library that would be designed with computer science education in mind,\nI was very excited to explore this.</p>\n<h2 class=\"font-mono text-2xl md:text-3xl my-3 mx-auto font-semibold\">Joy</h2>\n<p class=\"font-mono text-sm my-4 mx-auto\">That library is <a href=\"https://github.com/Sudha247/ocaml-joy\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">Joy</a>, inspired by the <a href=\"https://github.com/fossunited/joy\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">Python library</a> of the same name. An SVG\nrendering library with a focus on simplicity, composability, and elegance.\nWhile the original Python library had a functional style to it, translating it\nto OCaml gave me a unique opportunity to demonstrate the degree to which FP\nsuits generative art.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">There was only bare-bone scaffolding in place when I joined the team. A few\ngeometric types, a <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">shape</code> variant type for polymorphism, and a simple\n<code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Stdlib.Graphics</code> backend. This period of development offered some challenges.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">The <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Graphics</code> backend used the <a href=\"https://en.wikipedia.org/wiki/X_Window_System\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">X window system</a>,\nwhich had known vulnerabilities (with some being 20+ years old!), had an awkward\ninterface (resolution had to be passed as a string??), and, most bothersome of all,\nthe entire window process had to be started and then killed and restarted every time\nyou wanted to change your sketch and view the new output. This made iteration\nawkward and much more time-consuming than it needed to be.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Regardless, I quickly began working through the roadmap adding new primitives,\ntransformations like <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">rotate</code>, and essential features like variable canvas size\nand the ability to render the axes for debugging. The recursion-heavy\nstyle that OCaml steers you towards was, initially, disorienting for me. The\nlack of utilities like Clojure's <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">range</code>, <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">take</code>, and <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">comp</code> was confusing and\nI did have to lean on ChatGPT to give me a starting point to work from on more\nthan one occasion.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">I trudged on, putting in plenty of PRs and generally enjoying a level of productivity\nI found very satisfying. I would have discussions with my roommate, a Clojure dev,\n\"Can you believe OCaml doesn't have <em>feature</em>!? Why would you do <em>x</em> in <em>y</em> way??\".\nThis continued for maybe the first month of my internship until one day, I\nstumbled upon <a href=\"https://v2.ocaml.org/learn/tutorials/99problems.html\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">99 OCaml Problems</a> and everything clicked for me.\nThe terse, tail-call optimized recursive style sort of revealed itself and I felt like I understood it all.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">By the time we had cemented the final API and the library had the ability to\nhandle more complex algorithms like <a href=\"https://en.wikipedia.org/wiki/Circle_packing\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">circle packing</a> and <a href=\"https://en.wikipedia.org/wiki/Vector_field\" class=\"font-mono underline hover:text-stone-600 transition duration-300 ease-in-out\" target=\"_blank\" rel=\"noopener noreferrer\">flow-fields</a>, I noticed\nsomething else I found interesting, there was <em>no mutability</em> in the entire library.\nAside from some behind-the-scenes state management that (I assume) was taking place in\nthe <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Graphics</code> module, which we hadn't touched, there were no <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">ref</code> types, or\ninternally mutable data structures, just pure functions mapping from one\nprimitive to another.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">This realization led me to a couple of conclusions: that functional programming\nis particularly well suited to generative art, and that it could be an excellent\nway to introduce computer science students to the paradigm. Most generative art\nalgorithms are a pure mapping from either a set of static constants, a random\nseed, or a user input like mouse position, to a list of primitives that get\npassed on to the rendering engine. While many may use mutability in realizing\ntheir art, it is very rarely <em>absolutely necessary</em>.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">More importantly, more so than almost any area of computer science, generative\nart is immediate. A beginner can write a simple program, a circle made of circles,\na spiral of colors, and get a result they can put on the fridge, so to speak,\nright away. This is crucial to ensuring that would-be developers form some\nself-motivation and momentum, there is very little that keeps you in that\npositive feedback loop like having a pretty picture to show off to your friends.\nDoubly so for children. Free from the complexity of web or game development, the\nconfounding \"undefined is not a function\" errors of dynamic languages, and the\nintimidating syntax of lisps or Rust, students can focus on learning algorithms.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">With this realization I went on to develop the rest of the library, consistently\nfinding satisfyingly elegant implementations or optimizations. Transformations\nare a 6 case match block, one for every shape, that returns a shape. Colors\ncould be handled by adding an optional tuple field to our color types, and\nrendering them could be optimized with <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Option.iter</code>. The function that adds a\n<code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">stroke</code> or <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">fill</code> color to a shape is a pure function that takes a color and\nshape, and returns a shape, not imperatively setting attributes of an object.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Writing the circle packing example, circle collision checking could be short\ncircuited by using a fold-like recursive function as opposed to the <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">reduce</code> or\n<code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">fold</code> I had initially used (both in my first OCaml draft and Clojure). The\nquadtree example was made very simple with OCaml's variant types, something I\nhad no experience with prior, and am now in love with. Writing tree algorithms in\nClojure is a nightmare of <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">NullPointerException</code>, and a constant fight with the\nborrow checker in Rust. OCaml turned that into a single match block of\n<code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Node | Leaf</code>. The flowfield example is a mapping from an array of smooth noise\nvalues to an array of lines.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Mutability was necessary in one place: handling the rendering context. Even in\nthis case, a global mutable singleton, OCaml provided an elegant and, more\nimportantly, safe solution with <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">option</code>. Either the context has been initialized\nand operations like rendering or fetching the canvas dimensions could be performed\nor it hadn't and an error is raised. There's no need to touch the inner value,\ncompare it to a null literal, or do any guesswork in this regard. <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Option.is_some</code>\nhandles that for you. When writing the HTML canvas backend this was an absolute\ngodsend. I think of my early days of learning to code with <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Quil</code>, a ClojureScript\nwrapper for p5.js, and how much frustration this would have saved me.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Coming into this project with no experience in OCaml or MLs as a whole, I wasn't\nsure what to expect, but in retrospect I am very much grateful that I was able\nto do this work in OCaml specifically. I look back at much of my self-education\nand remember all the frustration dynamic languages have given me, the unhelpful\nerrors and runtime crashes, as well as the mind-twisting frustration that learning\nRust caused me, and the conclusion I come to is this. Functional programming is\ngood, doubly so if its typed, and if we want new programmers to benefit from that\ngood then I think OCaml is our best bet. Additionally, that immediacy that is so\nnecessary for newcomers can be provided by creative coding. And luckily, FP suits\ncreative coding to a truly impressive degree. So it follows that the right OCaml\ncreative coding library could be an invaluable tool for teaching FP to a new\ngeneration of programmers. This is my goal with <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Joy</code>.</p>\n"
}