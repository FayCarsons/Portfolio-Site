{
  "title": "keytrie",
  "date": "November 17, 2024",
  "header": "<h1 class=\"font-mono text-3xl md:text-4xl my-4 mx-auto font-semibold\">Efficient key bindings with Tries</h1>",
  "body": "<p class=\"font-mono text-sm my-4 mx-auto\"><em>NOTE: This article and, to a degree, this entire website are currently a work\nin progress! Some things may look a little rough or not render correctly, please\nbare with me :3</em></p>\n<p class=\"font-mono text-sm my-4 mx-auto\">I love working with trees. There's something very satisfying about recursive\ntree traversals - the way they naturally break down complex problems into simple\nsolutions. I've found this to be true in almost every language I've used\n(even Rust...sometimes), but MLs like Haskell and OCaml lend themselves to this\nparticularly well.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">So when I found myself building an app with Vim-inspired key bindings in OCaml, I\nwas excited to realize that a specific type of tree, call a trie (pronounced\n\"try\") can be used to handle key bindings.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Let me show you how it works!</p>\n<h2 class=\"font-mono text-2xl md:text-3xl my-3 mx-auto font-semibold\">What are we building?</h2>\n<p class=\"font-mono text-sm my-4 mx-auto\">Let's imagine we're writing an app where you can move around with 'hjkl' keys, and use 'q' to quit.\nFirst, we need some basic types to represent our app's state:</p>\n<pre class=\"font-mono text-sm my-2 mx-auto block p-4 bg-gray-200 rounded-sm overflow-auto whitespace-pre\"><code class=\"language-ocaml\"><span class=\"hljs-comment\">(* Just the basics - whether we should quit and where our cursor is *)</span>\n<span class=\"hljs-keyword\">module</span> <span class=\"hljs-type\">App</span> = <span class=\"hljs-keyword\">struct</span>\n  <span class=\"hljs-keyword\">type</span> t =\n    { should_quit : <span class=\"hljs-built_in\">bool</span>\n    ; cursor_pos : <span class=\"hljs-built_in\">int</span> * <span class=\"hljs-built_in\">int</span>\n    }\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-comment\">(* Things we can do in our app *)</span>\n<span class=\"hljs-keyword\">module</span> <span class=\"hljs-type\">Action</span> = <span class=\"hljs-keyword\">struct</span>\n  <span class=\"hljs-keyword\">type</span> t =\n    | <span class=\"hljs-type\">Move</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">int</span> * <span class=\"hljs-built_in\">int</span> <span class=\"hljs-comment\">(* how far to move (lines, columns) *)</span>\n    | <span class=\"hljs-type\">Quit</span>\n\n  <span class=\"hljs-comment\">(* Apply an action to get a new app state *)</span>\n  <span class=\"hljs-keyword\">let</span> eval app = <span class=\"hljs-keyword\">function</span>\n    | <span class=\"hljs-type\">Move</span> (dline, dcolumn) -&gt;\n      <span class=\"hljs-keyword\">let</span> line, column = app.cursor_pos <span class=\"hljs-keyword\">in</span>\n      { app <span class=\"hljs-keyword\">with</span> cursor_pos = line + dline, column + dcolumn }\n    | <span class=\"hljs-type\">Quit</span> -&gt; { app <span class=\"hljs-keyword\">with</span> should_quit = <span class=\"hljs-literal\">true</span> }\n  ;;\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-keyword\">type</span> key_bind =\n  { keys : <span class=\"hljs-type\">Key</span>.t <span class=\"hljs-built_in\">list</span>\n  ; action : <span class=\"hljs-type\">Action</span>.t\n  }\n\n<span class=\"hljs-keyword\">let</span> default_keybinds =\n  [ { keys = [ <span class=\"hljs-type\">Key</span>.<span class=\"hljs-type\">Char</span> <span class=\"hljs-string\">'q'</span> ]; action = <span class=\"hljs-type\">Quit</span> }\n  ; { keys = [ <span class=\"hljs-type\">Key</span>.<span class=\"hljs-type\">Char</span> <span class=\"hljs-string\">'h'</span> ]; action = <span class=\"hljs-type\">Move</span> (<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>) }\n  ; { keys = [ <span class=\"hljs-type\">Key</span>.<span class=\"hljs-type\">Char</span> <span class=\"hljs-string\">'j'</span> ]; action = <span class=\"hljs-type\">Move</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) }\n  ; { keys = [ <span class=\"hljs-type\">Key</span>.<span class=\"hljs-type\">Char</span> <span class=\"hljs-string\">'k'</span> ]; action = <span class=\"hljs-type\">Move</span> (-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>) }\n  ; { keys = [ <span class=\"hljs-type\">Key</span>.<span class=\"hljs-type\">Char</span> <span class=\"hljs-string\">'l'</span> ]; action = <span class=\"hljs-type\">Move</span> (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>) } \n  ]\n;;\n</code></pre>\n<h2 class=\"font-mono text-2xl md:text-3xl my-3 mx-auto font-semibold\">The tricky part</h2>\n<p class=\"font-mono text-sm my-4 mx-auto\">Now, how do we actually match key-presses to actions? The naive way would be to:</p>\n<ul class=\"list-disc list-inside\">\n<li class=\"font-mono text-sm mx-auto\">Push keys onto a linked list as they come in</li>\n<li class=\"font-mono text-sm mx-auto\">Check if that list matches any of our bindings</li>\n<li class=\"font-mono text-sm mx-auto\">If one matches, do the action and clear the list</li>\n<li class=\"font-mono text-sm mx-auto\">Otherwise continue, clearing the list if it gets too big</li>\n</ul>\n<p class=\"font-mono text-sm my-4 mx-auto\">This would work! But it's not great - every time we get a new key, we have to\ncheck all the keys we've gotten against <em>every</em> key in <em>every</em> binding. If\nwe've got a lot of key bindings, that's going to get slow.</p>\n<h2 class=\"font-mono text-2xl md:text-3xl my-3 mx-auto font-semibold\">Enter the Trie</h2>\n<p class=\"font-mono text-sm my-4 mx-auto\">[ 'd' ]      &lt;- root, which would contain every character mapped to a (potentially empty) sub-tree\n\\\n'o'<br>\n/  \\\n0   'g'\n\\\n1</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">This is where tries come in! Think of a trie as a tree where each path from root\nto leaf spells out a sequence - in our app's case, a sequence of keys that maps to an\naction. When we insert the mappings 'do' → 0 and 'dog' → 1, we get the structure\nshown above.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Notice how both sequences share the path 'd' → 'o' before diverging.\nThis is the key insight behind tries: common prefixes are stored just once, and\nwe can walk down the tree one element at a time until we either find a value\n(meaning we've matched a complete sequence) or hit a dead end.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Here's how we represent our trie in OCaml types:</p>\n<pre class=\"font-mono text-sm my-2 mx-auto block p-4 bg-gray-200 rounded-sm overflow-auto whitespace-pre\"><code class=\"language-ocaml\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-type\">Key_trie</span> = <span class=\"hljs-keyword\">struct</span>\n  <span class=\"hljs-keyword\">type</span> t = <span class=\"hljs-type\">Root</span> <span class=\"hljs-keyword\">of</span> branch\n  <span class=\"hljs-keyword\">and</span> branch = (<span class=\"hljs-type\">Key</span>.t, node) <span class=\"hljs-type\">Hashtbl</span>.t\n  <span class=\"hljs-keyword\">and</span> node =\n    | <span class=\"hljs-type\">Leaf</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-type\">Action</span>.t    <span class=\"hljs-comment\">(* We found an action! *)</span>\n    | <span class=\"hljs-type\">Branch</span> <span class=\"hljs-keyword\">of</span> branch    <span class=\"hljs-comment\">(* More keys to go... *)</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"font-mono text-sm my-4 mx-auto\">One notable difference in how we've structured our trie nodes: in a traditional\ntrie, nodes can have both children and a value because any string that we use to\nquery the trie has a known length - when we've reached the end of the string we\nknow that's where our value should be. This generally includes situations with\nchar streams as well, in those situations its generally what we have that\nmatters, not what we may get. If you're using a trie for something like a search\nengine, you want to show suggestions based on what's been typed <em>so far</em>,\nand that has a known length!</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">But in our case, our nodes either have children <em>or</em> a value, never both. This\nis because we're dealing with a stream of keystrokes, we can't know how many are\ncoming. So we need the trie structure itself to tell us whether we've gotten a\ncomplete sequence.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">One other detail: the <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">Root</code> constructor wrapping our branch type (the <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">type t =  Root of branch</code> bit). Since a branch and the root are technically the same thing\nunder the hood, we needed a way to tell them apart in our type system. This\nprevents us from accidentally passing the entire trie somewhere that expected\na sub-tree. This is called the newtype pattern and, while out of the scope of\nthis article I encourage you to look it up if you're new to typed functional\nprogramming.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Moving forward, loading up our key-binds looks like this:</p>\n<pre class=\"font-mono text-sm my-2 mx-auto block p-4 bg-gray-200 rounded-sm overflow-auto whitespace-pre\"><code class=\"language-ocaml\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-type\">Key_trie</span> = <span class=\"hljs-keyword\">struct</span>\n  <span class=\"hljs-comment\">(* previous code ... *)</span>\n\n  <span class=\"hljs-keyword\">let</span> load : key_bind -&gt; t -&gt; t =\n    <span class=\"hljs-keyword\">fun</span> { keys; action } (<span class=\"hljs-type\">Root</span> self) -&gt;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> go branch = <span class=\"hljs-keyword\">function</span>\n      | [ key ] -&gt;\n        <span class=\"hljs-comment\">(* Last key - this is where our action goes *)</span>\n        <span class=\"hljs-type\">Hashtbl</span>.replace branch key (<span class=\"hljs-type\">Leaf</span> action);\n        branch\n      | key :: more_keys -&gt;\n        (<span class=\"hljs-keyword\">match</span> <span class=\"hljs-type\">Hashtbl</span>.find_opt branch key <span class=\"hljs-keyword\">with</span>\n         | <span class=\"hljs-type\">Some</span> (<span class=\"hljs-type\">Leaf</span> _) -&gt;\n           <span class=\"hljs-comment\">(* Someone already has a shorter binding - don't override it *)</span>\n           branch\n         | <span class=\"hljs-type\">Some</span> (<span class=\"hljs-type\">Branch</span> children) -&gt; go children more_keys\n         | <span class=\"hljs-type\">None</span> -&gt;\n           <span class=\"hljs-comment\">(* New branch! *)</span>\n           <span class=\"hljs-keyword\">let</span> children = <span class=\"hljs-type\">Hashtbl</span>.create num_keys <span class=\"hljs-keyword\">in</span>\n           <span class=\"hljs-type\">Hashtbl</span>.add branch key (<span class=\"hljs-type\">Branch</span> children);\n           go children more_keys)\n      | <span class=\"hljs-literal\">[]</span> -&gt; \n        <span class=\"hljs-comment\">(* This can't happen because we exit the loop when we encounter the last\n           key in the list *)</span>\n        failwith <span class=\"hljs-string\">\"Unreachable!\"</span>\n    <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-type\">Root</span> (go self keys)\n  ;;\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"font-mono text-sm my-4 mx-auto\">Now we can define our trie iterator type:</p>\n<pre class=\"font-mono text-sm my-2 mx-auto block p-4 bg-gray-200 rounded-sm overflow-auto whitespace-pre\"><code class=\"language-ocaml\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-type\">Iter</span> = <span class=\"hljs-keyword\">struct</span>\n  <span class=\"hljs-keyword\">type</span> iter = <span class=\"hljs-type\">Iter</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-type\">Key_trie</span>.branch\n  <span class=\"hljs-keyword\">type</span> search_result =\n    | <span class=\"hljs-type\">Got</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-type\">Action</span>.t\n    | <span class=\"hljs-type\">Next</span> <span class=\"hljs-keyword\">of</span> iter\n    | <span class=\"hljs-type\">Nothing</span>\n\n  <span class=\"hljs-keyword\">let</span> create (<span class=\"hljs-type\">Root</span> root) = <span class=\"hljs-type\">Iter</span> root\n\n  <span class=\"hljs-keyword\">let</span> next (<span class=\"hljs-type\">Iter</span> self) key =\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-type\">Hashtbl</span>.find_opt self key <span class=\"hljs-keyword\">with</span>\n    | <span class=\"hljs-type\">Some</span> (<span class=\"hljs-type\">Leaf</span> action) -&gt; <span class=\"hljs-type\">Got</span> action\n    | <span class=\"hljs-type\">Some</span> (<span class=\"hljs-type\">Branch</span> next) -&gt; <span class=\"hljs-type\">Next</span> (<span class=\"hljs-type\">Iter</span> next)\n    | <span class=\"hljs-type\">None</span> -&gt; <span class=\"hljs-type\">Nothing</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"font-mono text-sm my-4 mx-auto\">Again, we use the newtype pattern for our <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">iter</code> type to get a bit more\ntype safety, but maybe more interestingly we also define a type just for the\nresult of the <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">next</code> function. While not required, this is a strategy I find\nmyself using increasingly often.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Instead of some combination of option, either, or result, which would\neffectively model our state but would lose the semantic meaning and be a bit\nharder to understand, we define something which fills both of those needs. It's\nexactly what we need, each variant communicates its own meaning, and its scope\nis small enough that missing out on the standard library's modules for those\ntypes doesn't really matter.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">Now that we have our iterator and associated functions we can write out our\nkeystroke handler function.</p>\n<pre class=\"font-mono text-sm my-2 mx-auto block p-4 bg-gray-200 rounded-sm overflow-auto whitespace-pre\"><code class=\"language-ocaml\"><span class=\"hljs-keyword\">let</span> handle_keystroke : <span class=\"hljs-type\">App</span>.t -&gt; <span class=\"hljs-type\">Key_trie</span>.t -&gt; <span class=\"hljs-built_in\">unit</span> =\n  <span class=\"hljs-keyword\">fun</span> app_state keybinds -&gt;\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> go iter =\n    <span class=\"hljs-keyword\">let</span> key = poll_keystroke <span class=\"hljs-literal\">()</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-type\">Iter</span>.next iter key <span class=\"hljs-keyword\">with</span>\n    | <span class=\"hljs-type\">Got</span> action -&gt;\n      <span class=\"hljs-type\">App</span>.eval action app;\n      <span class=\"hljs-comment\">(* Start over *)</span>\n      go (<span class=\"hljs-type\">Iter</span>.create keybinds) \n    | <span class=\"hljs-type\">Next</span> next_step -&gt; \n      <span class=\"hljs-comment\">(* Continue *)</span>\n      go next_step \n    | <span class=\"hljs-type\">Nothing</span> -&gt; \n      <span class=\"hljs-comment\">(* Start over *)</span>\n      go (<span class=\"hljs-type\">Iter</span>.create keybinds)\n  <span class=\"hljs-keyword\">in</span>\n  go (<span class=\"hljs-type\">Iter</span>.create keybinds)\n;;\n</code></pre>\n<p class=\"font-mono text-sm my-4 mx-auto\">Super simple, we get a key then try to advance. If we get an action we evaluate\nit and start the iterator back from the root, if not we continue. If we hit a\ndead end we also restart from the root.</p>\n<p class=\"font-mono text-sm my-4 mx-auto\">This method:</p>\n<ol class=\"list-decimal list-inside\">\n<li class=\"font-mono text-sm mx-auto\">Is much faster than the naive approach.</li>\n<li class=\"font-mono text-sm mx-auto\">Makes the control flow clear</li>\n<li class=\"font-mono text-sm mx-auto\">Makes it easy to add user-defined bindings</li>\n<li class=\"font-mono text-sm mx-auto\">Works great with blocking and async IO</li>\n</ol>\n<p class=\"font-mono text-sm my-4 mx-auto\">Ultimately, there are a few other things you'd want to add to get parity with\nVim. Keeping track of pressed modifiers, handle <code class=\"font-mono bg-gray-200 text-sm px-2 py-1 rounded\">esc</code> separately so that it can\nrestart the iterator. But this covers a surprising amount, and is efficient and\nelegant! Now go write a text editor!</p>\n"
}